<!-- Meine Netze Content: Übersicht über gemeldete und zugewiesene Geisternetze -->
<div class="section section-negative-margin">
    <!-- Erste Tabelle: Gemeldete Netze -->
    <div class="section-header">
        <div class="section-header-content">
            <h2>Gemeldete Netze</h2>
            <p class="muted">Übersicht über alle von dir gemeldeten Geisternetze.</p>
        </div>
        <!-- Filter Button: Öffnet/schließt Filter-Panel -->
        <button id="filter-toggle-btn" class="btn-filter filter-toggle-btn" onclick="toggleFilterPanel()">
            <span class="material-symbols-rounded" id="filter-icon">filter_list</span>
            <span id="filter-text">Filter</span>
        </button>
    </div>
    
    <!-- Filter Panel: Filter-Optionen für Größe, Status und Zeit -->
    <div id="filter-panel" class="filter-panel">
        <div class="filter-panel-grid">
            <!-- Größe Filter -->
            <div>
                <label class="filter-label">Größe</label>
                <div class="filter-input-group">
                    <input type="number" id="filter-size-min" placeholder="Min" class="filter-input">
                    <span class="filter-separator">-</span>
                    <input type="number" id="filter-size-max" placeholder="Max" class="filter-input">
                </div>
            </div>
            
            <!-- Status Filter -->
            <div>
                <label class="filter-label">Status</label>
                <div class="filter-checkbox-group">
                    <label class="filter-checkbox-label">
                        <input type="checkbox" id="filter-status-gemeldet" checked class="filter-checkbox">
                        <span class="filter-checkbox-text">GEMELDET</span>
                    </label>
                    <label class="filter-checkbox-label">
                        <input type="checkbox" id="filter-status-bergung" checked class="filter-checkbox">
                        <span class="filter-checkbox-text">BERGUNG_BEVORSTEHEND</span>
                    </label>
                    <label class="filter-checkbox-label">
                        <input type="checkbox" id="filter-status-verschollen" checked class="filter-checkbox">
                        <span class="filter-checkbox-text">VERSCHOLLEN</span>
                    </label>
                </div>
            </div>
            
            <!-- Zeit Filter -->
            <div>
                <label class="filter-label">Gemeldet am</label>
                <select id="filter-time" class="filter-select">
                    <option value="all">Alle</option>
                    <option value="today">Heute</option>
                    <option value="7days">Letzte 7 Tage</option>
                    <option value="30days">Letzte 30 Tage</option>
                </select>
            </div>
        </div>
        <div class="filter-actions">
            <button type="button" class="btn btn-secondary filter-reset-btn" onclick="resetFilters()">Zurücksetzen</button>
        </div>
    </div>
    
    <!-- Tabelle: Gemeldete Netze mit Sortier- und Filterfunktionen -->
    <div class="table-container">
        <table class="ghostnet-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Standort</th>
                    <!-- Sortierbare Spalte: Größe -->
                    <th class="sortable sortable-header" onclick="sortTable('size')">
                        Größe
                        <span class="sort-icon" id="sort-icon-size">
                            <span class="material-symbols-rounded">unfold_more</span>
                        </span>
                    </th>
                    <!-- Sortierbare Spalte: Status -->
                    <th class="sortable sortable-header" onclick="sortTable('status')">
                        Status
                        <span class="sort-icon" id="sort-icon-status">
                            <span class="material-symbols-rounded">unfold_more</span>
                        </span>
                    </th>
                    <!-- Sortierbare Spalte: Gemeldet am (Standard-Sortierung: absteigend) -->
                    <th class="sortable sortable-header" onclick="sortTable('date')">
                        Gemeldet am
                        <span class="sort-icon" id="sort-icon-date">
                            <span class="material-symbols-rounded">arrow_downward</span>
                        </span>
                    </th>
                    <!-- Aktionen-Spalte: Löschen-Button -->
                    <th></th>
                </tr>
            </thead>
            <tbody id="reported-table-body">
                <tr>
                    <td colspan="6" class="table-empty-cell">
                        <p class="muted">Laden...</p>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
    
    <!-- Zweite Tabelle: Zu bergende Netze -->
    <div class="section-header section-spacer">
        <div class="section-header-content">
            <h2>Zu bergende Netze</h2>
            <p class="muted">Übersicht über alle Geisternetze, die dir zur Bergung zugewiesen wurden.</p>
        </div>
        <button id="filter-toggle-btn-assigned" class="btn-filter filter-toggle-btn" onclick="toggleFilterPanelAssigned()">
            <span class="material-symbols-rounded" id="filter-icon-assigned">filter_list</span>
            <span id="filter-text-assigned">Filter</span>
        </button>
    </div>
    
    <!-- Filter Panel for Assigned Nets -->
    <div id="filter-panel-assigned" class="filter-panel">
        <div class="filter-panel-grid">
            <!-- Größe Filter -->
            <div>
                <label class="filter-label">Größe</label>
                <div class="filter-input-group">
                    <input type="number" id="filter-size-min-assigned" placeholder="Min" class="filter-input">
                    <span class="filter-separator">-</span>
                    <input type="number" id="filter-size-max-assigned" placeholder="Max" class="filter-input">
                </div>
            </div>
            
            <!-- Status Filter -->
            <div>
                <label class="filter-label">Status</label>
                <div class="filter-checkbox-group">
                    <label class="filter-checkbox-label">
                        <input type="checkbox" id="filter-status-bergung-assigned" checked class="filter-checkbox">
                        <span class="filter-checkbox-text">BERGUNG_BEVORSTEHEND</span>
                    </label>
                    <label class="filter-checkbox-label">
                        <input type="checkbox" id="filter-status-geborgen-assigned" checked class="filter-checkbox">
                        <span class="filter-checkbox-text">GEBORGEN</span>
                    </label>
                </div>
            </div>
            
            <!-- Zeit Filter -->
            <div>
                <label class="filter-label">Zugewiesen am</label>
                <select id="filter-time-assigned" class="filter-select">
                    <option value="all">Alle</option>
                    <option value="today">Heute</option>
                    <option value="7days">Letzte 7 Tage</option>
                    <option value="30days">Letzte 30 Tage</option>
                </select>
            </div>
        </div>
        <div class="filter-actions">
            <button type="button" class="btn btn-secondary filter-reset-btn" onclick="resetFiltersAssigned()">Zurücksetzen</button>
        </div>
    </div>
    
    <div class="table-container">
        <table class="ghostnet-table">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Standort</th>
                    <th class="sortable sortable-header" onclick="sortTableAssigned('size')">
                        Größe
                        <span class="sort-icon" id="sort-icon-size-assigned">
                            <span class="material-symbols-rounded">unfold_more</span>
                        </span>
                    </th>
                    <th class="sortable sortable-header" onclick="sortTableAssigned('status')">
                        Status
                        <span class="sort-icon" id="sort-icon-status-assigned">
                            <span class="material-symbols-rounded">unfold_more</span>
                        </span>
                    </th>
                    <th class="sortable sortable-header" onclick="sortTableAssigned('date')">
                        Zugewiesen am
                        <span class="sort-icon" id="sort-icon-date-assigned">
                            <span class="material-symbols-rounded">arrow_downward</span>
                        </span>
                    </th>
                    <th></th>
                </tr>
            </thead>
            <tbody id="assigned-table-body">
                <tr>
                    <td colspan="6" class="table-empty-cell">
                        <p class="muted">Laden...</p>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</div>

<script>
    (function() {
        'use strict';
        
        function formatDate(dateField) {
            if (!dateField || dateField === null) {
                return 'N/A';
            }
            
            try {
                if (Array.isArray(dateField)) {
                    const date = new Date(dateField[0], dateField[1] - 1, dateField[2], 
                        dateField[3] || 0, dateField[4] || 0);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleDateString('de-DE', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }
                } else if (typeof dateField === 'string') {
                    const date = new Date(dateField);
                    if (!isNaN(date.getTime())) {
                        return date.toLocaleDateString('de-DE', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                    }
                }
            } catch (e) {
                console.error('Date parse error:', e);
            }
            return 'N/A';
        }
        
        function formatLocation(net) {
            if (net.latitude !== null && net.latitude !== undefined && 
                net.longitude !== null && net.longitude !== undefined) {
                return `${net.latitude.toFixed(6)}, ${net.longitude.toFixed(6)}`;
            } else if (net.location && net.location.trim() !== '') {
                return net.location;
            }
            return 'N/A';
        }
        
        function getStatusClass(status) {
            if (!status || status.trim() === '') return 'unknown';
            const statusUpper = status.toUpperCase();
            if (statusUpper === 'GEMELDET') {
                return 'gemeldet';
            } else if (statusUpper === 'BERGUNG_BEVORSTEHEND') {
                return 'bergung-bevorstehend';
            } else if (statusUpper === 'GEBORGEN') {
                return 'geborgen';
            } else if (statusUpper === 'VERSCHOLLEN') {
                return 'verschollen';
            }
            return 'unknown';
        }
        
        // Alle gemeldeten Netze für Filterung speichern
        let allReportedNets = [];
        
        // Alle zu bergenden Netze für Filterung speichern
        let allAssignedNets = [];
        
        // Sortierungs-Status für gemeldete Netze
        let currentSortColumn = 'date'; // Default: Gemeldet am
        let currentSortDirection = 'desc'; // Default: descending
        
        // Sortierungs-Status für zu bergende Netze
        let currentSortColumnAssigned = 'date'; // Default: Zugewiesen am
        let currentSortDirectionAssigned = 'desc'; // Default: descending
        
        // Sortierungs-Funktionen
        function sortTable(column) {
            // Wenn derselbe Spalten-Kopf geklickt wird, Richtung umkehren
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                // Neue Spalte, Standard: aufsteigend
                currentSortColumn = column;
                currentSortDirection = 'asc';
            }
            
            // Sortierungs-Icons aktualisieren
            updateSortIcons();
            
            // Sortierung und Filterung anwenden
            applyFilters();
        }
        
        function updateSortIcons() {
            // Alle Icons zurücksetzen
            const icons = ['size', 'status', 'date'];
            icons.forEach(col => {
                const iconEl = document.getElementById(`sort-icon-${col}`);
                if (iconEl) {
                    const iconSpan = iconEl.querySelector('.material-symbols-rounded');
                    if (iconSpan) {
                        if (col === currentSortColumn) {
                            iconSpan.textContent = currentSortDirection === 'asc' ? 'arrow_upward' : 'arrow_downward';
                            iconEl.style.opacity = '1';
                        } else {
                            iconSpan.textContent = 'unfold_more';
                            iconEl.style.opacity = '0.5';
                        }
                    }
                }
            });
        }
        
        function sortNets(nets) {
            if (!nets || nets.length === 0) return nets;
            
            const sorted = [...nets];
            
            sorted.sort((a, b) => {
                let comparison = 0;
                
                switch (currentSortColumn) {
                    case 'size':
                        const sizeA = extractSizeNumber(a.estimatedSize) || 0;
                        const sizeB = extractSizeNumber(b.estimatedSize) || 0;
                        comparison = sizeA - sizeB;
                        break;
                    
                    case 'status':
                        const statusA = (a.status || '').trim().toUpperCase();
                        const statusB = (b.status || '').trim().toUpperCase();
                        comparison = statusA.localeCompare(statusB, 'de');
                        break;
                    
                    case 'date':
                        const dateA = parseDate(a.createdAt || a.reportedAt);
                        const dateB = parseDate(b.createdAt || b.reportedAt);
                        if (dateA && dateB) {
                            comparison = dateA.getTime() - dateB.getTime();
                        } else if (dateA) {
                            comparison = 1;
                        } else if (dateB) {
                            comparison = -1;
                        } else {
                            comparison = 0;
                        }
                        break;
                    
                    default:
                        return 0;
                }
                
                // Sortierungs-Richtung anwenden
                return currentSortDirection === 'asc' ? comparison : -comparison;
            });
            
            return sorted;
        }
        
        function parseDate(dateField) {
            if (!dateField || dateField === null) return null;
            
            try {
                if (Array.isArray(dateField)) {
                    return new Date(dateField[0], dateField[1] - 1, dateField[2], 
                        dateField[3] || 0, dateField[4] || 0);
                } else if (typeof dateField === 'string') {
                    return new Date(dateField);
                }
            } catch (e) {
                console.error('Date parse error:', e);
            }
            return null;
        }
        
        // Filter-Funktionen
        function extractSizeNumber(sizeStr) {
            if (!sizeStr || sizeStr.trim() === '') return null;
            // Versuchen, Zahl aus Strings wie "10m²", "ca. 20-30m²", "20m²", etc. zu extrahieren
            const match = sizeStr.match(/(\d+(?:\.\d+)?)/);
            return match ? parseFloat(match[1]) : null;
        }
        
        function filterReportedNets(nets) {
            let filtered = [...nets];
            
            // Größe filtern
            const minSize = document.getElementById('filter-size-min').value;
            const maxSize = document.getElementById('filter-size-max').value;
            
            if (minSize !== '' || maxSize !== '') {
                filtered = filtered.filter(net => {
                    const sizeNum = extractSizeNumber(net.estimatedSize);
                    if (sizeNum === null) return false;
                    
                    const min = minSize !== '' ? parseFloat(minSize) : null;
                    const max = maxSize !== '' ? parseFloat(maxSize) : null;
                    
                    if (min !== null && sizeNum < min) return false;
                    if (max !== null && sizeNum > max) return false;
                    return true;
                });
            }
            
            // Status filtern
            const gemeldetChecked = document.getElementById('filter-status-gemeldet').checked;
            const bergungChecked = document.getElementById('filter-status-bergung').checked;
            const verschollenChecked = document.getElementById('filter-status-verschollen').checked;
            
            if (!gemeldetChecked || !bergungChecked || !verschollenChecked) {
                filtered = filtered.filter(net => {
                    const status = (net.status || '').trim().toUpperCase();
                    if (gemeldetChecked && status === 'GEMELDET') return true;
                    if (bergungChecked && status === 'BERGUNG_BEVORSTEHEND') return true;
                    if (verschollenChecked && status === 'VERSCHOLLEN') return true;
                    return false;
                });
            }
            
            // Zeit filtern
            const timeFilter = document.getElementById('filter-time').value;
            if (timeFilter !== 'all') {
                const now = new Date();
                let cutoffDate = null;
                
                if (timeFilter === 'today') {
                    cutoffDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                } else if (timeFilter === '7days') {
                    cutoffDate = new Date(now);
                    cutoffDate.setDate(cutoffDate.getDate() - 7);
                } else if (timeFilter === '30days') {
                    cutoffDate = new Date(now);
                    cutoffDate.setDate(cutoffDate.getDate() - 30);
                }
                
                if (cutoffDate) {
                    filtered = filtered.filter(net => {
                        const dateField = net.createdAt || net.reportedAt;
                        if (!dateField || dateField === null) return false;
                        
                        let netDate = null;
                        try {
                            if (Array.isArray(dateField)) {
                                netDate = new Date(dateField[0], dateField[1] - 1, dateField[2], 
                                    dateField[3] || 0, dateField[4] || 0);
                            } else if (typeof dateField === 'string') {
                                netDate = new Date(dateField);
                            }
                            
                            if (netDate && !isNaN(netDate.getTime())) {
                                return netDate >= cutoffDate;
                            }
                        } catch (e) {
                            console.error('Date parse error:', e);
                        }
                        return false;
                    });
                }
            }
            
            return filtered;
        }
        
        function renderReportedTable(nets) {
            const tbody = document.getElementById('reported-table-body');
            if (!tbody) return;
            
            if (!nets || nets.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="table-empty-cell"><p class="muted">Noch keine gemeldeten Netze vorhanden.</p></td></tr>';
                return;
            }
            
            tbody.innerHTML = nets.map(net => {
                const status = (net.status && net.status.trim() !== '') ? net.status : 'Unbekannt';
                const statusUpper = status.toUpperCase();
                const statusDisplay = status.replace(/_/g, ' ');
                const statusClass = getStatusClass(status);
                const locationDisplay = formatLocation(net);
                const estimatedSize = (net.estimatedSize && net.estimatedSize.trim() !== '') ? net.estimatedSize : 'N/A';
                const reportedDate = formatDate(net.createdAt || net.reportedAt);
                
                // Löschen-Button - aktiviert für GEMELDET und VERSCHOLLEN Status
                const canDelete = statusUpper === 'GEMELDET' || statusUpper === 'VERSCHOLLEN';
                const deleteButton = `<button class="btn-delete ${!canDelete ? 'btn-delete-disabled' : ''}" ${!canDelete ? 'disabled' : ''} onclick="${canDelete ? `openDeleteModal(${net.id})` : ''}" title="${canDelete ? 'Meldung löschen' : 'Nur für GEMELDET oder VERSCHOLLEN Status verfügbar'}">
                        <span class="material-symbols-rounded">delete</span>
                        Löschen
                    </button>`;
                
                return `
                    <tr>
                        <td>#${net.id || 'N/A'}</td>
                        <td>${locationDisplay}</td>
                        <td>${estimatedSize}</td>
                        <td><span class="status-badge status-${statusClass}">${statusDisplay}</span></td>
                        <td>${reportedDate}</td>
                        <td>${deleteButton}</td>
                    </tr>
                `;
            }).join('');
        }
        
        function loadReportedTable() {
            const tbody = document.getElementById('reported-table-body');
            if (!tbody) return;
            
            fetch('/api/ghostnets/my-reports')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    allReportedNets = data || [];
                    applyFilters();
                })
                .catch(error => {
                    console.error('Error loading reported nets:', error);
                    tbody.innerHTML = '<tr><td colspan="6" class="table-empty-cell"><p class="muted">Fehler beim Laden: ' + error.message + '</p></td></tr>';
                });
        }
        
        function applyFilters() {
            const filtered = filterReportedNets(allReportedNets);
            const sorted = sortNets(filtered);
            renderReportedTable(sorted);
        }
        
        // sortTable global für onclick
        window.sortTable = sortTable;
        
        // Filter-Funktionen für zu bergende Netze
        function filterAssignedNets(nets) {
            let filtered = [...nets];
            
            // Größe filtern
            const minSize = document.getElementById('filter-size-min-assigned').value;
            const maxSize = document.getElementById('filter-size-max-assigned').value;
            
            if (minSize !== '' || maxSize !== '') {
                filtered = filtered.filter(net => {
                    const sizeNum = extractSizeNumber(net.estimatedSize);
                    if (sizeNum === null) return false;
                    
                    const min = minSize !== '' ? parseFloat(minSize) : null;
                    const max = maxSize !== '' ? parseFloat(maxSize) : null;
                    
                    if (min !== null && sizeNum < min) return false;
                    if (max !== null && sizeNum > max) return false;
                    return true;
                });
            }
            
            // Status filtern
            const bergungChecked = document.getElementById('filter-status-bergung-assigned').checked;
            const geborgenChecked = document.getElementById('filter-status-geborgen-assigned').checked;
            
            if (!bergungChecked || !geborgenChecked) {
                filtered = filtered.filter(net => {
                    const status = (net.status || '').trim().toUpperCase();
                    if (bergungChecked && status === 'BERGUNG_BEVORSTEHEND') return true;
                    if (geborgenChecked && status === 'GEBORGEN') return true;
                    return false;
                });
            }
            
            // Zeit filtern
            const timeFilter = document.getElementById('filter-time-assigned').value;
            if (timeFilter !== 'all') {
                const now = new Date();
                let cutoffDate = null;
                
                if (timeFilter === 'today') {
                    cutoffDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                } else if (timeFilter === '7days') {
                    cutoffDate = new Date(now);
                    cutoffDate.setDate(cutoffDate.getDate() - 7);
                } else if (timeFilter === '30days') {
                    cutoffDate = new Date(now);
                    cutoffDate.setDate(cutoffDate.getDate() - 30);
                }
                
                if (cutoffDate) {
                    filtered = filtered.filter(net => {
                        const dateField = net.reportedAt || net.createdAt;
                        if (!dateField || dateField === null) return false;
                        
                        let netDate = null;
                        try {
                            if (Array.isArray(dateField)) {
                                netDate = new Date(dateField[0], dateField[1] - 1, dateField[2], 
                                    dateField[3] || 0, dateField[4] || 0);
                            } else if (typeof dateField === 'string') {
                                netDate = new Date(dateField);
                            }
                            
                            if (netDate && !isNaN(netDate.getTime())) {
                                return netDate >= cutoffDate;
                            }
                        } catch (e) {
                            console.error('Date parse error:', e);
                        }
                        return false;
                    });
                }
            }
            
            return filtered;
        }
        
        function sortAssignedNets(nets) {
            if (!nets || nets.length === 0) return nets;
            
            const sorted = [...nets];
            
            sorted.sort((a, b) => {
                let comparison = 0;
                
                switch (currentSortColumnAssigned) {
                    case 'size':
                        const sizeA = extractSizeNumber(a.estimatedSize) || 0;
                        const sizeB = extractSizeNumber(b.estimatedSize) || 0;
                        comparison = sizeA - sizeB;
                        break;
                    
                    case 'status':
                        const statusA = (a.status || '').trim().toUpperCase();
                        const statusB = (b.status || '').trim().toUpperCase();
                        comparison = statusA.localeCompare(statusB, 'de');
                        break;
                    
                    case 'date':
                        const dateA = parseDate(a.reportedAt || a.createdAt);
                        const dateB = parseDate(b.reportedAt || b.createdAt);
                        if (dateA && dateB) {
                            comparison = dateA.getTime() - dateB.getTime();
                        } else if (dateA) {
                            comparison = 1;
                        } else if (dateB) {
                            comparison = -1;
                        } else {
                            comparison = 0;
                        }
                        break;
                    
                    default:
                        return 0;
                }
                
                // Sortierungs-Richtung anwenden
                return currentSortDirectionAssigned === 'asc' ? comparison : -comparison;
            });
            
            return sorted;
        }
        
        function renderAssignedTable(nets) {
            const tbody = document.getElementById('assigned-table-body');
            if (!tbody) return;
            
            if (!nets || nets.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="table-empty-cell"><p class="muted">Keine Netze gefunden, die den Filterkriterien entsprechen.</p></td></tr>';
                return;
            }
            
            tbody.innerHTML = nets.map(net => {
                        const status = (net.status && net.status.trim() !== '') ? net.status : 'Unbekannt';
                        const statusUpper = status.toUpperCase();
                        const statusDisplay = status.replace(/_/g, ' ');
                        const statusClass = getStatusClass(status);
                        const locationDisplay = formatLocation(net);
                        const estimatedSize = (net.estimatedSize && net.estimatedSize.trim() !== '') ? net.estimatedSize : 'N/A';
                        // reportedAt als Zuweisungs-Datum verwenden (wenn Status auf BERGUNG_BEVORSTEHEND geändert wurde)
                        const assignedDate = formatDate(net.reportedAt || net.createdAt);
                        
                        // Recovery button - nur sichtbar, wenn nicht GEBORGEN
                        const isGeborgen = statusUpper === 'GEBORGEN';
                        const recoverButton = `<button class="btn-recover ${isGeborgen ? 'btn-recover-disabled' : ''}" ${isGeborgen ? 'disabled' : ''} onclick="${!isGeborgen ? `openRecoverModal(${net.id})` : ''}" title="${!isGeborgen ? 'Bergung bestätigen' : 'Bereits geborgen'}">
                                <span class="material-symbols-rounded">check_circle</span>
                                Bergung bestätigen
                            </button>`;
                        
                        return `
                            <tr>
                                <td>#${net.id || 'N/A'}</td>
                                <td>${locationDisplay}</td>
                                <td>${estimatedSize}</td>
                                <td><span class="status-badge status-${statusClass}">${statusDisplay}</span></td>
                                <td>${assignedDate}</td>
                                <td>${recoverButton}</td>
                            </tr>
                        `;
                    }).join('');
        }
        
        function loadAssignedTable() {
            const tbody = document.getElementById('assigned-table-body');
            if (!tbody) return;
            
            fetch('/api/ghostnets/my-assignments')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('HTTP ' + response.status);
                    }
                    return response.json();
                })
                .then(data => {
                    allAssignedNets = data || [];
                    applyFiltersAssigned();
                })
                .catch(error => {
                    console.error('Error loading assigned nets:', error);
                    tbody.innerHTML = '<tr><td colspan="6" class="table-empty-cell"><p class="muted">Fehler beim Laden: ' + error.message + '</p></td></tr>';
                });
        }
        
        function applyFiltersAssigned() {
            const filtered = filterAssignedNets(allAssignedNets);
            const sorted = sortAssignedNets(filtered);
            renderAssignedTable(sorted);
        }
        
        // Sortierungs-Funktionen für zu bergende Netze
        function sortTableAssigned(column) {
            // Wenn derselbe Spalten-Kopf geklickt wird, Richtung umkehren
            if (currentSortColumnAssigned === column) {
                currentSortDirectionAssigned = currentSortDirectionAssigned === 'asc' ? 'desc' : 'asc';
            } else {
                // Neue Spalte, Standard: aufsteigend
                currentSortColumnAssigned = column;
                currentSortDirectionAssigned = 'asc';
            }
            
            // Sortierungs-Icons aktualisieren
            updateSortIconsAssigned();
            
            // Sortierung und Filterung anwenden
            applyFiltersAssigned();
        }
        
        function updateSortIconsAssigned() {
            // Alle Icons zurücksetzen
            const icons = ['size', 'status', 'date'];
            icons.forEach(col => {
                const iconEl = document.getElementById(`sort-icon-${col}-assigned`);
                if (iconEl) {
                    const iconSpan = iconEl.querySelector('.material-symbols-rounded');
                    if (iconSpan) {
                        if (col === currentSortColumnAssigned) {
                            iconSpan.textContent = currentSortDirectionAssigned === 'asc' ? 'arrow_upward' : 'arrow_downward';
                            iconEl.style.opacity = '1';
                        } else {
                            iconSpan.textContent = 'unfold_more';
                            iconEl.style.opacity = '0.5';
                        }
                    }
                }
            });
        }
        
        // sortTableAssigned global für onclick
        window.sortTableAssigned = sortTableAssigned;
        
        // Filter-Panel anzeigen/verstecken
        window.toggleFilterPanel = function() {
            const panel = document.getElementById('filter-panel');
            const icon = document.getElementById('filter-icon');
            const text = document.getElementById('filter-text');
            
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                icon.textContent = 'filter_list_off';
                text.textContent = 'Filter ausblenden';
            } else {
                panel.style.display = 'none';
                icon.textContent = 'filter_list';
                text.textContent = 'Filter';
            }
        };
        
        // Filter zurücksetzen
        window.resetFilters = function() {
            document.getElementById('filter-size-min').value = '';
            document.getElementById('filter-size-max').value = '';
            document.getElementById('filter-status-gemeldet').checked = true;
            document.getElementById('filter-status-bergung').checked = true;
            document.getElementById('filter-status-verschollen').checked = true;
            document.getElementById('filter-time').value = 'all';
            applyFilters();
        };
        
        // Filter-Panel anzeigen/verstecken für zu bergende Netze
        window.toggleFilterPanelAssigned = function() {
            const panel = document.getElementById('filter-panel-assigned');
            const icon = document.getElementById('filter-icon-assigned');
            const text = document.getElementById('filter-text-assigned');
            
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                icon.textContent = 'filter_list_off';
                text.textContent = 'Filter ausblenden';
            } else {
                panel.style.display = 'none';
                icon.textContent = 'filter_list';
                text.textContent = 'Filter';
            }
        };
        
        // Filter für zu bergende Netze zurücksetzen
        window.resetFiltersAssigned = function() {
            document.getElementById('filter-size-min-assigned').value = '';
            document.getElementById('filter-size-max-assigned').value = '';
            document.getElementById('filter-status-bergung-assigned').checked = true;
            document.getElementById('filter-status-geborgen-assigned').checked = true;
            document.getElementById('filter-time-assigned').value = 'all';
            applyFiltersAssigned();
        };
        
        // Filter-Event-Listener anhängen
        function attachFilterListeners() {
            const minSizeInput = document.getElementById('filter-size-min');
            const maxSizeInput = document.getElementById('filter-size-max');
            const gemeldetCheckbox = document.getElementById('filter-status-gemeldet');
            const bergungCheckbox = document.getElementById('filter-status-bergung');
            const verschollenCheckbox = document.getElementById('filter-status-verschollen');
            const timeSelect = document.getElementById('filter-time');
            
            if (minSizeInput) minSizeInput.addEventListener('input', applyFilters);
            if (maxSizeInput) maxSizeInput.addEventListener('input', applyFilters);
            if (gemeldetCheckbox) gemeldetCheckbox.addEventListener('change', applyFilters);
            if (bergungCheckbox) bergungCheckbox.addEventListener('change', applyFilters);
            if (verschollenCheckbox) verschollenCheckbox.addEventListener('change', applyFilters);
            if (timeSelect) timeSelect.addEventListener('change', applyFilters);
        }
        
        // Filter-Event-Listener für zu bergende Netze anhängen
        function attachFilterListenersAssigned() {
            const minSizeInput = document.getElementById('filter-size-min-assigned');
            const maxSizeInput = document.getElementById('filter-size-max-assigned');
            const bergungCheckbox = document.getElementById('filter-status-bergung-assigned');
            const geborgenCheckbox = document.getElementById('filter-status-geborgen-assigned');
            const timeSelect = document.getElementById('filter-time-assigned');
            
            if (minSizeInput) minSizeInput.addEventListener('input', applyFiltersAssigned);
            if (maxSizeInput) maxSizeInput.addEventListener('input', applyFiltersAssigned);
            if (bergungCheckbox) bergungCheckbox.addEventListener('change', applyFiltersAssigned);
            if (geborgenCheckbox) geborgenCheckbox.addEventListener('change', applyFiltersAssigned);
            if (timeSelect) timeSelect.addEventListener('change', applyFiltersAssigned);
        }
        
        // Beide Tabellen laden
        function loadTables() {
            loadReportedTable();
            loadAssignedTable();
        }
        
        // Versuchen, sofort zu laden
        if (document.getElementById('reported-table-body') && document.getElementById('assigned-table-body')) {
            loadTables();
            // Filter-Event-Listener anhängen und Sortierungs-Icons aktualisieren nach kurzer Verzögerung um DOM bereit zu machen
            setTimeout(() => {
                attachFilterListeners();
                attachFilterListenersAssigned();
                updateSortIcons();
                updateSortIconsAssigned();
            }, 100);
        } else {
            // Wiederholen, wenn Tabellen-Body nicht gefunden
            const retryInterval = setInterval(() => {
                if (document.getElementById('reported-table-body') && document.getElementById('assigned-table-body')) {
                    loadTables();
                    setTimeout(() => {
                        attachFilterListeners();
                        attachFilterListenersAssigned();
                        updateSortIcons();
                        updateSortIconsAssigned();
                    }, 100);
                    clearInterval(retryInterval);
                }
            }, 100);
            
            // Nach 2 Sekunden stoppen
            setTimeout(() => clearInterval(retryInterval), 2000);
        }
        
        // Löschen-Modal-Funktionen
        window.openDeleteModal = function(ghostNetId) {
            // Geisternetz-Details abrufen
            fetch(`/api/ghostnets`)
                .then(response => response.json())
                .then(data => {
                    const ghostNet = data.find(net => net.id === ghostNetId);
                    if (ghostNet) {
                        showDeleteConfirmModal(ghostNet);
                    } else {
                        alert('Geisternetz nicht gefunden');
                    }
                })
                .catch(error => {
                    console.error('Error fetching ghost net:', error);
                    alert('Fehler beim Laden der Daten');
                });
        };
        
        function showDeleteConfirmModal(ghostNet) {
            const modal = document.getElementById('delete-confirm-modal');
            modal.style.display = 'flex';
            modal.setAttribute('data-ghostnet-id', ghostNet.id);
            
            // Standort formatieren
            let locationDisplay = 'N/A';
            if (ghostNet.latitude !== null && ghostNet.latitude !== undefined && 
                ghostNet.longitude !== null && ghostNet.longitude !== undefined) {
                locationDisplay = `${ghostNet.latitude.toFixed(6)}, ${ghostNet.longitude.toFixed(6)}`;
            } else if (ghostNet.location && ghostNet.location.trim() !== '') {
                locationDisplay = ghostNet.location;
            }
            
            // Größe formatieren
            const estimatedSize = (ghostNet.estimatedSize && ghostNet.estimatedSize.trim() !== '') ? ghostNet.estimatedSize : 'N/A';
            
            // Modal-Inhalt aktualisieren
            const modalContent = modal.querySelector('.modal-content');
            modalContent.innerHTML = `
                <div class="modal-header">
                    <h2>Meldung löschen</h2>
                    <button class="modal-close" onclick="window.closeDeleteModal()">
                        <span class="material-symbols-rounded">close</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="modal-text">Möchten Sie diese Meldung wirklich löschen? Diese Aktion kann nicht rückgängig gemacht werden.</p>
                    <div class="modal-info-box">
                        <div class="modal-info-row">
                            <strong class="modal-info-label">ID:</strong>
                            <span class="modal-info-value">#${ghostNet.id || 'N/A'}</span>
                        </div>
                        <div class="modal-info-row">
                            <strong class="modal-info-label">Standort:</strong>
                            <span class="modal-info-value">${locationDisplay}</span>
                        </div>
                        <div class="modal-info-row">
                            <strong class="modal-info-label">Größe:</strong>
                            <span class="modal-info-value">${estimatedSize}</span>
                        </div>
                    </div>
                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" onclick="window.closeDeleteModal()">Abbrechen</button>
                        <button type="button" class="btn btn-danger" onclick="window.confirmDelete()">Löschen</button>
                    </div>
                </div>
            `;
        }
        
        window.closeDeleteModal = function() {
            document.getElementById('delete-confirm-modal').style.display = 'none';
            document.getElementById('delete-confirm-modal').removeAttribute('data-ghostnet-id');
        };
        
        window.confirmDelete = function() {
            const ghostNetId = document.getElementById('delete-confirm-modal').getAttribute('data-ghostnet-id');
            if (!ghostNetId) return;
            
            // Lade-Status anzeigen
            const modalContent = document.querySelector('#delete-confirm-modal .modal-content');
            modalContent.innerHTML = `
                <div class="modal-loading">
                    <div class="spinner"></div>
                    <p>Wird gelöscht...</p>
                </div>
            `;
            
            fetch(`/api/ghostnets/${ghostNetId}`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        throw new Error(text || 'Fehler beim Löschen');
                    });
                }
                return response;
            })
            .then(() => {
                // Erfolgsmeldung anzeigen
                modalContent.innerHTML = `
                    <div class="modal-success">
                        <span class="material-symbols-rounded modal-success-icon">check_circle</span>
                        <h2 class="modal-success-title">Erfolgreich gelöscht!</h2>
                        <p class="modal-success-text">Die Meldung wurde gelöscht.</p>
                    </div>
                `;
                
                // Modal schließen und neu laden nach Verzögerung
                setTimeout(() => {
                    window.closeDeleteModal();
                    loadReportedTable(); // neu laden und aktuelle Filter anwenden
                }, 2000);
            })
            .catch(error => {
                console.error('Error deleting ghost net:', error);
                modalContent.innerHTML = `
                    <div class="modal-header">
                        <h2>Fehler</h2>
                        <button class="modal-close" onclick="window.closeDeleteModal()">
                            <span class="material-symbols-rounded">close</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p class="modal-text">Fehler beim Löschen: ${error.message}</p>
                        <div class="form-actions">
                            <button type="button" class="btn btn-primary" onclick="window.closeDeleteModal()">Schließen</button>
                        </div>
                    </div>
                `;
            });
        };
        
        // Recovery-Modal-Funktionen
        window.openRecoverModal = function(ghostNetId) {
            // Geisternetz-Details abrufen
            fetch(`/api/ghostnets`)
                .then(response => response.json())
                .then(data => {
                    const ghostNet = data.find(net => net.id === ghostNetId);
                    if (ghostNet) {
                        showRecoverConfirmModal(ghostNet);
                    } else {
                        alert('Geisternetz nicht gefunden');
                    }
                })
                .catch(error => {
                    console.error('Error fetching ghost net:', error);
                    alert('Fehler beim Laden der Daten');
                });
        };
        
        function showRecoverConfirmModal(ghostNet) {
            const modal = document.getElementById('recover-confirm-modal');
            modal.style.display = 'flex';
            modal.setAttribute('data-ghostnet-id', ghostNet.id);
            
            // Standort formatieren
            let locationDisplay = 'N/A';
            if (ghostNet.latitude !== null && ghostNet.latitude !== undefined && 
                ghostNet.longitude !== null && ghostNet.longitude !== undefined) {
                locationDisplay = `${ghostNet.latitude.toFixed(6)}, ${ghostNet.longitude.toFixed(6)}`;
            } else if (ghostNet.location && ghostNet.location.trim() !== '') {
                locationDisplay = ghostNet.location;
            }
            
            // Größe formatieren
            const estimatedSize = (ghostNet.estimatedSize && ghostNet.estimatedSize.trim() !== '') ? ghostNet.estimatedSize : 'N/A';
            
            // Modal-Inhalt aktualisieren
            const modalContent = modal.querySelector('.modal-content');
            modalContent.innerHTML = `
                <div class="modal-header">
                    <h2>Bergung bestätigen</h2>
                    <button class="modal-close" onclick="window.closeRecoverModal()">
                        <span class="material-symbols-rounded">close</span>
                    </button>
                </div>
                <div class="modal-body">
                    <p class="modal-text">Möchten Sie die Bergung dieses Geisternetzes bestätigen?</p>
                    <div class="modal-info-box">
                        <div class="modal-info-row">
                            <strong class="modal-info-label">ID:</strong>
                            <span class="modal-info-value">#${ghostNet.id || 'N/A'}</span>
                        </div>
                        <div class="modal-info-row">
                            <strong class="modal-info-label">Standort:</strong>
                            <span class="modal-info-value">${locationDisplay}</span>
                        </div>
                        <div class="modal-info-row">
                            <strong class="modal-info-label">Größe:</strong>
                            <span class="modal-info-value">${estimatedSize}</span>
                        </div>
                    </div>
                    <p class="modal-text modal-text-spacing">Der Status wird auf "Geborgen" gesetzt.</p>
                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" onclick="window.closeRecoverModal()">Abbrechen</button>
                        <button type="button" class="btn btn-primary" onclick="window.confirmRecover()">Bestätigen</button>
                    </div>
                </div>
            `;
        }
        
        window.closeRecoverModal = function() {
            document.getElementById('recover-confirm-modal').style.display = 'none';
            document.getElementById('recover-confirm-modal').removeAttribute('data-ghostnet-id');
        };
        
        window.confirmRecover = function() {
            const ghostNetId = document.getElementById('recover-confirm-modal').getAttribute('data-ghostnet-id');
            if (!ghostNetId) return;
            
            // Lade-Status anzeigen
            const modalContent = document.querySelector('#recover-confirm-modal .modal-content');
            modalContent.innerHTML = `
                <div class="modal-loading">
                    <div class="spinner"></div>
                    <p>Wird bestätigt...</p>
                </div>
            `;
            
            fetch(`/api/ghostnets/${ghostNetId}/recover`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        throw new Error(text || 'Fehler beim Bestätigen');
                    });
                }
                return response.json();
            })
            .then(data => {
                // Erfolgsmeldung anzeigen
                modalContent.innerHTML = `
                    <div class="modal-success">
                        <span class="material-symbols-rounded modal-success-icon">check_circle</span>
                        <h2 class="modal-success-title">Bergung bestätigt!</h2>
                        <p class="modal-success-text">Das Geisternetz wurde als geborgen markiert.</p>
                    </div>
                `;
                
                // Modal schließen und neu laden nach Verzögerung
                setTimeout(() => {
                    window.closeRecoverModal();
                    loadAssignedTable(); // neu laden und aktuelle Filter anwenden
                }, 2000);
            })
            .catch(error => {
                console.error('Error recovering ghost net:', error);
                modalContent.innerHTML = `
                    <div class="modal-header">
                        <h2>Fehler</h2>
                        <button class="modal-close" onclick="window.closeRecoverModal()">
                            <span class="material-symbols-rounded">close</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        <p class="modal-text">Fehler beim Bestätigen: ${error.message}</p>
                        <div class="form-actions">
                            <button type="button" class="btn btn-primary" onclick="window.closeRecoverModal()">Schließen</button>
                        </div>
                    </div>
                `;
            });
        };
    })();
</script>

<!-- Löschen-Bestätigungs-Modal -->
<div id="delete-confirm-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <!-- Inhalt wird dynamisch eingefügt -->
    </div>
</div>

<!-- Bergung-Bestätigungs-Modal -->
<div id="recover-confirm-modal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <!-- Inhalt wird dynamisch eingefügt -->
    </div>
</div>

<script>
    // Modal schließen, wenn außerhalb des Modals geklickt wird
    document.getElementById('delete-confirm-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            window.closeDeleteModal();
        }
    });
    
    document.getElementById('recover-confirm-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            window.closeRecoverModal();
        }
    });
</script>
